/**
 * AI-powered regex pattern generation using LLM
 */

import { APIClient } from '../utils/api.js';

export class AIRegex {
    /**
     * Generate regex pattern from natural language description
     */
    async generatePattern(description, mode = 'find') {
        try {
            const response = await APIClient.post('/llm/generate-regex', {
                description,
                mode
            });

            if (response.success) {
                return {
                    pattern: response.pattern,
                    flags: response.flags || 'g',
                    explanation: response.explanation,
                    examples: response.examples || [],
                    replacement: response.replacement || ''
                };
            } else {
                throw new Error(response.error || 'Failed to generate pattern');
            }
        } catch (error) {
            // Fallback to custom prompt if dedicated endpoint not available
            console.warn('Dedicated regex endpoint not available, using custom prompt');
            return this.generatePatternFallback(description, mode);
        }
    }

    /**
     * Fallback method using custom-prompt endpoint
     */
    async generatePatternFallback(description, mode = 'find') {
        const prompt = this.buildRegexPrompt(description, mode);

        try {
            const response = await APIClient.post('/llm/custom-prompt', {
                content: '',
                prompt,
                preserve_markdown: false
            });

            if (response.success) {
                return this.parseRegexResponse(response.content);
            } else {
                throw new Error(response.error || 'Failed to generate pattern');
            }
        } catch (error) {
            console.error('AI regex generation error:', error);
            throw new Error(`Failed to generate pattern: ${error.message}`);
        }
    }

    /**
     * Build prompt for regex generation
     */
    buildRegexPrompt(description, mode) {
        return `You are a regex pattern generator. Generate a regular expression pattern based on this description:

"${description}"

Mode: ${mode === 'find' ? 'Find/match text' : 'Find and replace'}

Respond with a JSON object containing:
- pattern: the regex pattern (without delimiters)
- flags: regex flags (e.g., "g", "gm", "gi")
- explanation: brief explanation of what the pattern does
- examples: array of 2-3 example matches
${mode === 'replace' ? '- replacement: suggested replacement pattern' : ''}

Format your response as valid JSON only, no additional text.

Example response:
{
  "pattern": "^#{1,6}\\\\s+.+$",
  "flags": "gm",
  "explanation": "Matches all markdown headers from # to ######",
  "examples": ["# Title", "## Subtitle", "### Section"],
  "replacement": ""
}`;
    }

    /**
     * Parse LLM response to extract regex components
     */
    parseRegexResponse(responseText) {
        try {
            // Try to parse as JSON first
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                return {
                    pattern: parsed.pattern || '',
                    flags: parsed.flags || 'g',
                    explanation: parsed.explanation || '',
                    examples: parsed.examples || [],
                    replacement: parsed.replacement || ''
                };
            }

            // Fallback: try to extract pattern from text
            const patternMatch = responseText.match(/pattern["\s:]+([^\n"]+)/i);
            const flagsMatch = responseText.match(/flags["\s:]+([^\n"]+)/i);
            const explanationMatch = responseText.match(/explanation["\s:]+([^\n"]+)/i);

            return {
                pattern: patternMatch ? patternMatch[1].trim() : '',
                flags: flagsMatch ? flagsMatch[1].trim() : 'g',
                explanation: explanationMatch ? explanationMatch[1].trim() : 'Pattern generated by AI',
                examples: [],
                replacement: ''
            };
        } catch (error) {
            console.error('Failed to parse regex response:', error);
            throw new Error('Could not parse AI response. Please try a different description.');
        }
    }

    /**
     * Suggest improvements to existing pattern
     */
    async improvePattern(pattern, description = '') {
        const prompt = `Analyze this regex pattern and suggest improvements:

Pattern: ${pattern}
${description ? `Context: ${description}` : ''}

Provide:
1. Issues with the current pattern (if any)
2. Improved pattern
3. Explanation of improvements

Format as JSON:
{
  "improved_pattern": "...",
  "issues": ["..."],
  "improvements": "...",
  "flags": "g"
}`;

        try {
            const response = await APIClient.post('/llm/custom-prompt', {
                content: '',
                prompt,
                preserve_markdown: false
            });

            if (response.success) {
                return this.parseImprovementResponse(response.content);
            } else {
                throw new Error('Failed to analyze pattern');
            }
        } catch (error) {
            console.error('Pattern improvement error:', error);
            throw error;
        }
    }

    /**
     * Parse improvement response
     */
    parseImprovementResponse(responseText) {
        try {
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                return {
                    improvedPattern: parsed.improved_pattern || '',
                    issues: parsed.issues || [],
                    improvements: parsed.improvements || '',
                    flags: parsed.flags || 'g'
                };
            }
        } catch (error) {
            console.error('Failed to parse improvement response:', error);
        }

        return null;
    }

    /**
     * Explain existing pattern
     */
    async explainPattern(pattern, flags = 'g') {
        const prompt = `Explain what this regular expression does in simple terms:

Pattern: ${pattern}
Flags: ${flags}

Provide:
1. Plain English explanation
2. What it matches
3. 2-3 examples of matching text

Keep the explanation concise and user-friendly.`;

        try {
            const response = await APIClient.post('/llm/custom-prompt', {
                content: '',
                prompt,
                preserve_markdown: false
            });

            if (response.success) {
                return response.content;
            } else {
                throw new Error('Failed to explain pattern');
            }
        } catch (error) {
            console.error('Pattern explanation error:', error);
            throw error;
        }
    }

    /**
     * Generate replacement pattern
     */
    async generateReplacement(pattern, description) {
        const prompt = `Given this regex pattern and goal, suggest a replacement pattern:

Pattern: ${pattern}
Goal: ${description}

Provide the replacement pattern that achieves the goal.
If using capture groups, explain the groups used.

Format as JSON:
{
  "replacement": "...",
  "explanation": "...",
  "example_before": "...",
  "example_after": "..."
}`;

        try {
            const response = await APIClient.post('/llm/custom-prompt', {
                content: '',
                prompt,
                preserve_markdown: false
            });

            if (response.success) {
                return this.parseReplacementResponse(response.content);
            } else {
                throw new Error('Failed to generate replacement');
            }
        } catch (error) {
            console.error('Replacement generation error:', error);
            throw error;
        }
    }

    /**
     * Parse replacement response
     */
    parseReplacementResponse(responseText) {
        try {
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const parsed = JSON.parse(jsonMatch[0]);
                return {
                    replacement: parsed.replacement || '',
                    explanation: parsed.explanation || '',
                    exampleBefore: parsed.example_before || '',
                    exampleAfter: parsed.example_after || ''
                };
            }
        } catch (error) {
            console.error('Failed to parse replacement response:', error);
        }

        return null;
    }
}
